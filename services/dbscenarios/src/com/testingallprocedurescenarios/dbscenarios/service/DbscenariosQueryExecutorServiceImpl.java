/*Generated by WaveMaker Studio*/
package com.testingallprocedurescenarios.dbscenarios.service;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.Date;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.wavemaker.commons.MessageResource;
import com.wavemaker.runtime.data.dao.query.WMQueryExecutor;
import com.wavemaker.runtime.data.exception.BlobContentNotFoundException;
import com.wavemaker.runtime.data.exception.EntityNotFoundException;
import com.wavemaker.runtime.data.export.ExportOptions;
import com.wavemaker.runtime.data.model.QueryProcedureInput;

import com.testingallprocedurescenarios.dbscenarios.models.query.*;

@Service
public class DbscenariosQueryExecutorServiceImpl implements DbscenariosQueryExecutorService {

    private static final Logger LOGGER = LoggerFactory.getLogger(DbscenariosQueryExecutorServiceImpl.class);

    @Autowired
    @Qualifier("dbscenariosWMQueryExecutor")
    private WMQueryExecutor queryExecutor;

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<HqlMysqlAllTypesWithAliasResponse> executeHQL_MysqlAllTypesWithAlias(Pageable pageable) {
        Map<String, Object> params = new HashMap<>(0);


        return queryExecutor.executeNamedQuery("HQL_MysqlAllTypesWithAlias", params, HqlMysqlAllTypesWithAliasResponse.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobcolContentForHQL_MysqlAllTypesWithAlias() throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(0);


        HqlMysqlAllTypesWithAliasResponse _result =  queryExecutor.executeNamedQuery("HQL_MysqlAllTypesWithAlias", params, HqlMysqlAllTypesWithAliasResponse.class);
        if(_result.getBlobcol() == null) {
            LOGGER.debug("Blob content not exists for blobcol in query HQL_MysqlAllTypesWithAlias");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobcol", "query", "HQL_MysqlAllTypesWithAlias");
        }
        return new ByteArrayInputStream(_result.getBlobcol());
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportHQL_MysqlAllTypesWithAlias(ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(0);


        QueryProcedureInput<HqlMysqlAllTypesWithAliasResponse> queryInput = new QueryProcedureInput<>("HQL_MysqlAllTypesWithAlias", params, HqlMysqlAllTypesWithAliasResponse.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<SvGetBelowPk10Response> executeSV_GetBelowPK10(Pageable pageable) {
        Map<String, Object> params = new HashMap<>(0);


        return queryExecutor.executeNamedQuery("SV_GetBelowPK10", params, SvGetBelowPk10Response.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobColContentForSV_GetBelowPK10() throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(0);


        SvGetBelowPk10Response _result =  queryExecutor.executeNamedQuery("SV_GetBelowPK10", params, SvGetBelowPk10Response.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetBelowPK10");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobCol", "query", "SV_GetBelowPK10");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportSV_GetBelowPK10(ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(0);


        QueryProcedureInput<SvGetBelowPk10Response> queryInput = new QueryProcedureInput<>("SV_GetBelowPK10", params, SvGetBelowPk10Response.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public SvGetSingleRecordResponse executeSV_GetSingleRecord(Integer id) {
        Map<String, Object> params = new HashMap<>(1);

        params.put("Id", id);

        return queryExecutor.executeNamedQuery("SV_GetSingleRecord", params, SvGetSingleRecordResponse.class);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobColContentForSV_GetSingleRecord(Integer id) throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(1);

        params.put("Id", id);

        SvGetSingleRecordResponse _result =  queryExecutor.executeNamedQuery("SV_GetSingleRecord", params, SvGetSingleRecordResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetSingleRecord");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobCol", "query", "SV_GetSingleRecord");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<SvLoggedinUserResponse> executeSV_LoggedinUser(Pageable pageable) {
        Map<String, Object> params = new HashMap<>(0);


        return queryExecutor.executeNamedQuery("SV_LoggedinUser", params, SvLoggedinUserResponse.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobColContentForSV_LoggedinUser() throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(0);


        SvLoggedinUserResponse _result =  queryExecutor.executeNamedQuery("SV_LoggedinUser", params, SvLoggedinUserResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_LoggedinUser");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobCol", "query", "SV_LoggedinUser");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportSV_LoggedinUser(ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(0);


        QueryProcedureInput<SvLoggedinUserResponse> queryInput = new QueryProcedureInput<>("SV_LoggedinUser", params, SvLoggedinUserResponse.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

    @Transactional(value = "dbscenariosTransactionManager")
    @Override
    public Integer executeSV_InsertQueryUsingSystemParams(SvInsertQueryUsingSystemParamsRequest svInsertQueryUsingSystemParamsRequest) {
        Map<String, Object> params = new HashMap<>(12);

        params.put("BYTECOL", svInsertQueryUsingSystemParamsRequest.getBytecol());
        params.put("INTCOL", svInsertQueryUsingSystemParamsRequest.getIntcol());
        params.put("FLOATCOL", svInsertQueryUsingSystemParamsRequest.getFloatcol());
        params.put("LONGCOL", svInsertQueryUsingSystemParamsRequest.getLongcol());
        params.put("DOUBLECOL", svInsertQueryUsingSystemParamsRequest.getDoublecol());
        params.put("BIGINTCOL", svInsertQueryUsingSystemParamsRequest.getBigintcol());
        params.put("BIGDECCOL", svInsertQueryUsingSystemParamsRequest.getBigdeccol());
        params.put("CHARCOL", svInsertQueryUsingSystemParamsRequest.getCharcol());
        params.put("TEXTCOL", svInsertQueryUsingSystemParamsRequest.getTextcol());
        params.put("CLOBCOL", svInsertQueryUsingSystemParamsRequest.getClobcol());
        params.put("TIMESTAMPCOL", svInsertQueryUsingSystemParamsRequest.getTimestampcol());
        params.put("BOOLEANCOL", svInsertQueryUsingSystemParamsRequest.getBooleancol());

        return queryExecutor.executeNamedQueryForUpdate("SV_InsertQueryUsingSystemParams", params);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<SvByteDatetimeResponse> executeSV_ByteDatetime(Pageable pageable) {
        Map<String, Object> params = new HashMap<>(0);


        return queryExecutor.executeNamedQuery("SV_ByteDatetime", params, SvByteDatetimeResponse.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportSV_ByteDatetime(ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(0);


        QueryProcedureInput<SvByteDatetimeResponse> queryInput = new QueryProcedureInput<>("SV_ByteDatetime", params, SvByteDatetimeResponse.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<SvAllTypesData1Response> executeSV_ALlTypesData1(Pageable pageable) {
        Map<String, Object> params = new HashMap<>(0);


        return queryExecutor.executeNamedQuery("SV_ALlTypesData1", params, SvAllTypesData1Response.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobColContentForSV_ALlTypesData1() throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(0);


        SvAllTypesData1Response _result =  queryExecutor.executeNamedQuery("SV_ALlTypesData1", params, SvAllTypesData1Response.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_ALlTypesData1");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobCol", "query", "SV_ALlTypesData1");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportSV_ALlTypesData1(ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(0);


        QueryProcedureInput<SvAllTypesData1Response> queryInput = new QueryProcedureInput<>("SV_ALlTypesData1", params, SvAllTypesData1Response.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<SvGetByDateColResponse> executeSV_GetByDateCol(Date datecol, Pageable pageable) {
        Map<String, Object> params = new HashMap<>(1);

        params.put("datecol", datecol);

        return queryExecutor.executeNamedQuery("SV_GetByDateCol", params, SvGetByDateColResponse.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobColContentForSV_GetByDateCol(Date datecol) throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(1);

        params.put("datecol", datecol);

        SvGetByDateColResponse _result =  queryExecutor.executeNamedQuery("SV_GetByDateCol", params, SvGetByDateColResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetByDateCol");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobCol", "query", "SV_GetByDateCol");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportSV_GetByDateCol(Date datecol, ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(1);

        params.put("datecol", datecol);

        QueryProcedureInput<SvGetByDateColResponse> queryInput = new QueryProcedureInput<>("SV_GetByDateCol", params, SvGetByDateColResponse.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public Page<SvAllTypesDataResponse> executeSV_AllTypesData(Pageable pageable) {
        Map<String, Object> params = new HashMap<>(0);


        return queryExecutor.executeNamedQuery("SV_AllTypesData", params, SvAllTypesDataResponse.class, pageable);
    }

    @Transactional(value = "dbscenariosTransactionManager", readOnly = true)
    @Override
    public InputStream getBlobColContentForSV_AllTypesData() throws EntityNotFoundException {
        Map<String, Object> params = new HashMap<>(0);


        SvAllTypesDataResponse _result =  queryExecutor.executeNamedQuery("SV_AllTypesData", params, SvAllTypesDataResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_AllTypesData");
            throw new BlobContentNotFoundException(MessageResource.create("com.wavemaker.runtime.blob.content.not.found"), "blobCol", "query", "SV_AllTypesData");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager", timeout = 300, readOnly = true)
    @Override
    public void exportSV_AllTypesData(ExportOptions exportOptions, Pageable pageable, OutputStream outputStream) {
        Map<String, Object> params = new HashMap<>(0);


        QueryProcedureInput<SvAllTypesDataResponse> queryInput = new QueryProcedureInput<>("SV_AllTypesData", params, SvAllTypesDataResponse.class);

        queryExecutor.exportNamedQueryData(queryInput, exportOptions, pageable, outputStream);
    }

}